# 数据结构
## 定义
数据结构是指相互之间存在着一种或多种关系的数据元素的集合和该集合中数据元素之间的关系组成。记为：
Data_Structure=(D,R)
其中D是数据元素的集合，R是该集合中所有元素之间的关系的有限集合。
### 数据
所有能被输入到计算机中，且能被计算机处理的符号的集合。是计算机操作的对象的总称
### 数据元素
数据（集合）中的一个“个体”，数据及结构中讨论的基本单位
### 数据项
数据的不可分割的最小单位。一个数据元素可由若干个数据项组成
### 数据类型
在一种程序设计语言中，变量所具有的数据种类。整型、浮点型、字符型等等
## 逻辑结构 
在数据结构中，逻辑上可以将其分为线性结构和非线性结构
集合：数据结构中的元素之间除了“同属一个集合” 的相互关系外，别无其他关系；
线性结构：数据结构中的元素存在一对一的相互关系；
树形结构：数据结构中的元素存在一对多的相互关系；
图形结构：数据结构中的元素存在多对多的相互关系。
## 物理结构/存储结构
数据在计算机中的表示。物理结构是描述数据具体在内存中的存储（如：顺序结构、链式结构、索引结构、哈希结构）等
##数据处理
指对数据进行查找、插入、删除、合并、排序、统计以及简单计算等的操作过程

## 常用数据结构
* 数组 Array
* 栈 Stack
* 队列 Queue
* 链表 Linked List
* 树 Tree
* 图 Graph
* 堆 Heap
* 散列表 Hash

# 线性表
线性表是一种典型的线性结构。头结点无前驱有一个后继，尾节点无后继有一个前驱。链表只能顺序查找，定位一个元素的时间为O(N)，删除一个元素的时间为O(1)
## 线性表的顺序存储结构 顺序表
把线性表的结点按逻辑顺序依次存放在一组地址连续的存储单元里。用这种方法存储的线性表简称顺序表。是一种随机存取的存储结构。
## 线性链表
任意的存储单元来依次存放线性表的结点，这组存储单元即可以是连续的，也可以是不连续的，甚至是零散分布在内存中的任意位置上的
存储每个结点值的同时，还必须存储指示其后继结点的地址。data域是数据域，用来存放结点的值。next是指针域（亦称链域），用来存放结点的直接后继的地址（或位置）
### 单链表
每个结点的存储地址是存放在其前趋结点next域中，而开始结点无前趋，故应设头指针head指向开始结点。同时，由于最后一个结点无后继，故结点的指针域为空，即NULL。头插法建表(逆序)、尾插法建表(顺序)。增加头结点的目的是算法实现上的方便，但增大了内存开销。 
查找：只能从链表的头指针出发，顺链域next逐个结点往下搜索，直到搜索到第i个结点为止。因此，链表不是随机存取结构。
插入：先找到表的第i-1的存储位置，然后插入。新结点先连后继，再连前驱。
删除：首先找到ai-1的存储位置p。然后令p–>next指向ai的直接后继结点，即把ai从链上摘下。最后释放结点ai的空间.r=p->next;p->next=r->next;delete r。
判断一个单向链表中是否存在环的最佳方法是快慢指针。
### 静态链表
用一维数组来实现线性链表，这种用一维数组表示的线性链表，称为静态链表。静态：体现在表的容量是一定的。（数组的大小）；链表：插入与删除同前面所述的动态链表方法相同。静态链表中指针表示的是下一元素在数组中的位置
静态链表是用数组实现的，是顺序的存储结构，在物理地址上是连续的，而且需要预先分配大小。动态链表是用申请内存函数（C是malloc,C++是new）动态申请内存的，所以在链表的长度上没有限制。动态链表因为是动态申请内存的，所以每个节点的物理地址不连续，要通过指针来顺序访问。静态链表在插入、删除时也是通过修改指针域来实现的，与动态链表没有什么分别
### 循环链表
是一种头尾相接的链表。其特点是无须增加存储量，仅对表的链接方式稍作改变，即可使得表处理更加方便灵活
在单链表中，将终端结点的指针域NULL改为指向表头结点的或开始结点，就得到了单链形式的循环链表，并简单称为单循环链表。由于循环链表中没有NULL指针，故涉及遍历操作时，其终止条件就不再像非循环链表那样判断p或p—>next是否为空，而是判断它们是否等于某一指定指针，如头指针或尾指针等。
### 双向链表
在单链表的每个结点里再增加一个指向其直接前趋的指针域prior。这样就形成的链表中有两个方向不同的链。双链表一般由头指针唯一确定的，将头结点和尾结点链接起来构成循环链表，并称之为双向链表。设指针p指向某一结点，则双向链表结构的对称性可用下式描述：p—>prior—>next=p=p—>next—>prior。从两个方向搜索双链表，比从一个方向搜索双链表的方差要小。 
插入：先搞定插入节点的前驱和后继，再搞定后结点的前驱，最后搞定前结点的后继。
在有序双向链表中定位删除一个元素的平均时间复杂度为O(n)
可以直接删除当前指针所指向的节点。而不需要像单向链表中，删除一个元素必须找到其前驱。因此在插入数据时，单向链表和双向链表操作复杂度相同，而删除数据时，双向链表的性能优于单向链表

## 栈
栈(Stack)是限制在表的一端进行插入和删除运算的线性表，通常称插入、删除的这一端为栈顶(Top)，另一端为栈底(Bottom)。先进后出。top= -1时为空栈，top=0只能说明栈中只有一个元素，并且元素进栈时top应该自增
顺序存储栈：顺序存储结构
链栈：链式存储结构。插入和删除操作仅限制在链头位置上进行。栈顶指针就是链表的头指针。通常不会出现栈满的情况。 不需要判断栈满但需要判断栈空。
两个栈共用静态存储空间,对头使用也存在空间溢出问题。栈1的底在v[1]，栈2的底在V[m]，则栈满的条件是top[1]+1=top[2]。
基本操作：删除栈顶元素、判断栈是否为空以及将栈置为空栈等
对于n各元素的入栈问题，可能的出栈顺序有C(2n,n)/(n+1)个。
堆栈溢出一般是循环的递归调用、大数据结构的局部变量导致的
### 栈应用
进制转换
括号匹配的检验
行编辑程序
迷宫求解：若当前位置“可通”，则纳入路径，继续前进;若当前位置“不可通”，则后退，换方向继续探索;若四周“均无通路”，则将当前位置从路径中删除出去。
表达式求解：前缀、中缀、后缀。 
操作数之间的相对次序不变;
运算符的相对次序不同;
中缀式丢失了括弧信息，致使运算的次序不确定
前缀式的运算规则为:连续出现的两个操作数和在它们之前且紧靠它们的运算符构成一个最小表达式
后缀式的运算规则为:运算符在式中出现的顺序恰为表达式的运算顺序;每个运算符和在它之前出现且紧靠它的两个操作数构成一个最小表达式。
实现递归：多个函数嵌套调用的规则是：后调用先返回。
浏览器历史纪录，Android中的最近任务，Activity的启动模式，CPU中栈的实现，Word自动保存，解析计算式，解析xml/json。解析XML时，需要校验节点是否闭合，节点闭合的话，有头尾符号相对应，遇到头符号将其放入栈中，遇到尾符号时，弹出栈的内容，看是否有与之对应的头符号，栈的特性刚好符合符号匹配的就近原则。

## 队列
队列(Queue)也是一种运算受限的线性表。它只允许在表的一端进行插入，而在另一端进行删除。允许删除的一端称为队头(front)，允许插入的一端称为队尾(rear)。先进先出。
顺序队列：顺序存储结构。当头尾指针相等时队列为空。在非空队列里，头指针始终指向队头前一个位置，而尾指针始终指向队尾元素的实际位置
循环队列。在循环队列中进行出队、入队操作时，头尾指针仍要加1，朝前移动。只不过当头尾指针指向向量上界（MaxSize-1）时，其加1操作的结果是指向向量的下界0。除非向量空间真的被队列元素全部占用，否则不会上溢。因此，除一些简单的应用外，真正实用的顺序队列是循环队列。故队空和队满时头尾指针均相等。因此，我们无法通过front=rear来判断队列“空”还是“满”
链队列：链式存储结构。限制仅在表头删除和表尾插入的单链表。显然仅有单链表的头指针不便于在表尾做插入操作，为此再增加一个尾指针，指向链表的最后一个结点。
设尾指针的循环链表表示队列,则入队和出队算法的时间复杂度均为O(1)。用循环链表表示队列，必定有链表的头结点，入队操作在链表尾插入，直接插入在尾指针指向的节点后面，时间复杂度是常数级的；出队操作在链表表头进行，也就是删除表头指向的节点，时间复杂度也是常数级的。

队空条件：rear==front，但是一般需要引入新的标记来说明栈满还是栈空，比如每个位置布尔值

队满条件：(rear+1) % QueueSize==front，其中QueueSize为循环队列的最大长度
计算队列长度：（rear-front+QueueSize）% QueueSize
入队：（rear+1）% QueueSize
出队：（front+1）% QueueSize
假设以数组A[N]为容量存放循环队列的元素,其头指针是front,当前队列有X个元素,则队列的尾指针值为(front+X mod N)

## 串
串(String)是零个或多个字符组成的有限序列。长度为零的串称为空串(Empty String)，它不包含任何字符。通常将仅由一个或多个空格组成的串称为空白串(Blank String) 注意：空串和空白串的不同，例如“ ”和“”分别表示长度为1的空白串和长度为0的空串
定长顺序存储表示。静态存储分配的顺序表。
堆分配存储表示。存储空间是在程序执行过程中动态分配而得。所以也称为动态存储分配的顺序表
串的链式存储结构。

# 线性结构
数组和广义表可看成是一种特殊的线性表，其特殊在于: 表中的元素本身也是一种线性表。内存连续。根据下标在O(1)时间读/写任何元素。
二维数组，多维数组，广义表、树、图都属于非线性结构

## 树
一种非线性结构。树是递归结构，在树的定义中又用到了树的概念。

基本术语：
树结点：包含一个数据元素及若干指向子树的分支；
孩子结点：结点的子树的根称为该结点的孩子；
双亲结点：B结点是A结点的孩子，则A结点是B结点的双亲；
兄弟结点：同一双亲的孩子结点；
堂兄结点：同一层上结点；
结点层次：根结点的层定义为1；根的孩子为第二层结点，依此类推；
树的高（深）度：树中最大的结点层
结点的度：结点子树的个数
树的度： 树中最大的结点度。
叶子结点：也叫终端结点，是度为0的结点；
分枝结点：度不为0的结点（非终端结点）；
森林：互不相交的树集合；
有序树：子树有序的树，如：家族树；
无序树：不考虑子树的顺序；

## 二叉树
* 二叉树可以为空。二叉树结点的子树要区分左子树和右子树，即使只有一棵子树也要进行区分，说明它是左子树，还是右子树。这是二叉树与树的最主要的差别。注意区分：二叉树、二叉查找树/二叉排序树/二叉搜索树、二叉平衡(查找)树
* 二叉平衡树肯定是一颗二叉排序树。堆不是一颗二叉平衡树。
* 二叉树与树是不同的，二叉树不等价于分支树最多为二的有序树。当一个结点只包含一个子节点时，对于有序树并无左右孩子之分，而对于二叉树来说依然有左右孩子之分，所以二叉树与树是两种不同的结构。

* 性质：
    在二叉树的第 i 层上至多有2^(i-1)个结点。
    深度为 k 的二叉树上至多含 2^k-1 个结点（k≥1）
    对任何一棵二叉树，若它含有n0个叶子结点、n2个度为 2 的结点，则必存在关系式：n0= n2+1。
    具有 n 个结点的完全二叉树的深度为 log2(n+1) 。
    n个结点的二叉树中，完全二叉树具有最小的路径长度。
    如果对一棵有n个结点的完全二叉树的结点按层序编号,则对任一结点i（1<=i<=n),有： 
        如果i＝1，则结点i无双亲，是二叉树的根；如果i>1，则其双亲的编号是 i/2(整除）。
        如果2i>n，无左孩子；否则，其左孩子是结点2i。
        如果2i＋1>n，则结点i无右孩子；否则，其右孩子是结点2i＋1。

* 二叉树的存储结构
    顺序存储结构：仅仅适用于满或完全二叉树，结点之间的层次关系由性质5确定。
    二叉链表法：每个节点存储左子树和右子树。三叉链表：左子树、右子树、父节点，总的指针是n+2
    在有n个结点的二叉链表中，值为非空的链域的个数为n-1。在有N个结点的二叉链表中必定有2N个链域。除根结点外，其余N-1个结点都有一个父结点。所以，一共有N-1个非空链域，其余2N-(N-1)=N+1个为空链域。
    二叉链存储法也叫孩子兄弟法，左指针指向左孩子，右指针指向右兄弟。而中序遍历的顺序是左孩子，根，右孩子。这种遍历顺序与存储结构不同，因此需要堆栈保存中间结果。而中序遍历检索二叉树时，由于其存储结构跟遍历顺序相符，因此不需要用堆栈。

### 遍历二叉树和线索二叉树
遍历二叉树：使得每一个结点均被访问一次，而且仅被访问一次。非递归的遍历实现要利用栈。
*    先序遍历DLR：根节点->左子树->右子树
*    中序遍历LDR：左子树->根节点->右子树。必须要有中序遍历才能得到一棵二叉树的正确顺序
*    后续遍历LRD：左子树->右子树->根节点。需要栈的支持。
*    层次遍历：用一维数组存储二叉树时,总是以层次遍历的顺序存储结点。层次遍历应该借助队列。



